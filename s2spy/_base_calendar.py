"""BaseCalendar is a template for specific implementations of different calendars.
It includes most methods required for all calendar operations, except a specific __init__
and map_year method. These two have to be customized for each specific calendar.
"""
from abc import ABC, abstractmethod
from typing import Optional
from typing import Union
import numpy as np
import pandas as pd
import xarray as xr
from . import _resample

PandasData = (pd.Series, pd.DataFrame)
XArrayData = (xr.DataArray, xr.Dataset)


class BaseCalendar(ABC):
    @abstractmethod
    def __init__(
        self, anchor, freq, n_targets: Optional[int] = 1, max_lag: Optional[int] = None
    ):
        # Define the minimum variables here:
        self.n_targets = n_targets
        self.max_lag = max_lag
        self.anchor = anchor
        self.freq = freq
        self._nintervals = None
        self._skip_year = None

    @abstractmethod
    def _map_year(self, year):
        # map year much be implemented for each specific calendar.
        raise NotImplementedError

    def _get_nintervals(self) -> int:
        """Method to calculate the number of intervals that should be generated by
        _map year.

        Returns:
            int: Number of intervals for one anchor year.
        """
        periods_per_year = pd.Timedelta("365days") / pd.to_timedelta(self.freq)
        return (
            (self.max_lag + self.n_targets) if self.max_lag else int(periods_per_year)
        )

    def _get_skip_nyears(self) -> int:
        """Method to determine how many years need to be skipped to avoid overlapping
        data between anchor years

        Returns:
            int: Number of years that need to be skipped.
        """
        nintervals = pd.Timedelta("365days") // pd.to_timedelta(self.freq)
        periods_per_year = pd.Timedelta("365days") / pd.to_timedelta(self.freq)

        return (
            (np.ceil(nintervals / periods_per_year).astype(int) - 1)
            if self.max_lag
            else 0
        )

    def map_years(self, start: int = 1979, end: int = 2020) -> pd.DataFrame:
        """Return a periodic IntervalIndex for the given years.
        If the start and end years are the same, the Intervals for only that single
        year are returned.

        Args:
            start: The first year for which the calendar will be realized
            end: The last year for which the calendar will be realized

        Returns:
            Pandas DataFrame filled with Intervals of the calendar's frequency,
            counting backwards from the calendar's anchor_date.

        Example:

            >>> import s2spy.time
            >>> calendar = s2spy.time.AdventCalendar(anchor_date=(12, 31), freq='180d')
            >>> # note the leap year:
            >>> calendar.map_years(2020, 2022) # doctest: +NORMALIZE_WHITESPACE
            i_interval                 (target) 0                         1
            anchor_year
            2022         (2022-07-04, 2022-12-31]  (2022-01-05, 2022-07-04]
            2021         (2021-07-04, 2021-12-31]  (2021-01-05, 2021-07-04]
            2020         (2020-07-04, 2020-12-31]  (2020-01-06, 2020-07-04]

            >>> # To get a stacked representation:
            >>> calendar.map_years(2020, 2022).flat
            anchor_year  i_interval
            2022         0             (2022-07-04, 2022-12-31]
                         1             (2022-01-05, 2022-07-04]
            2021         0             (2021-07-04, 2021-12-31]
                         1             (2021-01-05, 2021-07-04]
            2020         0             (2020-07-04, 2020-12-31]
                         1             (2020-01-06, 2020-07-04]
            dtype: interval

        """
        self._first_year = start
        self._last_year = end
        self._first_timestamp = None
        self._last_timestamp = None

        return self

    def map_to_data(
        self,
        input_data: Union[pd.Series, pd.DataFrame, xr.Dataset, xr.DataArray],
    ) -> Union[pd.DataFrame, xr.Dataset]:
        """Map the calendar to input data period.

        Get datetime range from input data and generate corresponding interval index.
        This method guarantees that the generated interval (calendar) indices would be
        covered by the input
        data.
        Args:
            input_data: Input data for datetime mapping. Its index must be either
                pandas.DatetimeIndex, or an xarray `time` coordinate with datetime
                data.
        Returns:
            Pandas DataFrame or xarray Dataset filled with Intervals of the calendar's
            frequency. (see also ``map_years``)
        """
        # check the datetime order of input data
        if isinstance(input_data, PandasData):
            self._first_timestamp = input_data.index.min()
            self._last_timestamp = input_data.index.max()
        elif isinstance(input_data, XArrayData):
            self._first_timestamp = input_data.time.min()
            self._last_timestamp = input_data.time.max()
        else:
            raise ValueError(
                "incompatible input data format, please pass a pandas or xarray object"
            )

        # Set the years to None
        self.first_year = None
        self.last_year = None
        return self

    def _year_range_from_timestamps(self):
        map_first_year = self._first_timestamp.dt.year.values
        map_last_year = self._last_timestamp.dt.year.values

        # ensure that the input data could always cover the advent calendar
        # last date check
        if self._map_year(map_last_year).iloc[0].right > self._last_timestamp:
            map_last_year -= 1
        # first date check
        if self._map_year(map_first_year).iloc[-1].left < self._first_timestamp:
            map_first_year += 1

        # map year(s) and generate year realized advent calendar
        if map_last_year >= map_first_year:
            self._first_year = map_first_year
            self._last_year = map_last_year
        else:
            raise ValueError(
                "The input data could not cover the target advent calendar."
            )

        return self

    def get_intervals(self):
        """Method to retrieve updated intervals from the Calendar object."""
        if self._first_year is None:
            if self._first_timestamp is None:
                raise ValueError(
                    "Cannot retrieve intervals without map_years or "
                    "map_to_data having configured the calendar."
                )
            self._years_from_timestamps()

        year_range = range(
            self._last_year, self._first_year - 1, -(self._get_skip_nyears() + 1)
        )

        intervals = pd.concat([self._map_year(year) for year in year_range], axis=1).T

        intervals.index.name = "anchor_year"
        intervals = _resample.label_targets(self, intervals)
        return intervals

    @abstractmethod
    def show(self):
        """Display the intervals nicely"""
        raise NotImplementedError

    def __str__(self):
        return f"{self._nintervals} periods of {self.freq} leading up to {self.month}/{self.day}."

    def __repr__(self):
        # if self._intervals is not None:
        #     return repr(_resample.label_targets(self, self._intervals))
        props = ", ".join(
            [f"{k}={v}" for k, v in self.__dict__.items() if not k.startswith("_")]
        )
        calendar_name = self.__class__.__name__
        return f"{calendar_name}({props})"

    @property
    def flat(self):
        return self.get_intervals().stack()

    def discard(self, max_lag):  # or "set_max_lag"
        """Only keep indices up to the given max lag."""
        # or think of a nicer way to discard unneeded info
        raise NotImplementedError
