"""BaseCalendar is a template for specific implementations of different calendars.

The BaseCalendar includes most methods required for all calendar operations, except for
a set of abstract methods (e.g., __init__, _map_year_anchor, ...). These will have to be
customized for each specific calendar.
"""
from abc import ABC
from abc import abstractmethod
from typing import Union
import numpy as np
import pandas as pd
import xarray as xr
from . import utils


PandasData = (pd.Series, pd.DataFrame)
XArrayData = (xr.DataArray, xr.Dataset)


class BaseCalendar(ABC):
    """Base calendar class which serves as a template for specific implementations."""

    @abstractmethod
    def __init__(self, anchor, freq, n_targets: int = 1, max_lag: int = None):
        """For initializing calendars, the following six variables will be required."""
        self.n_targets = n_targets
        self.max_lag = max_lag
        self.anchor = anchor
        self.freq = freq
        self._first_timestamp = None
        self._first_year = None

    @abstractmethod
    def _map_year_anchor(self, year: int) -> pd.Timestamp:
        """Method to generate an anchor timestamp for your specific calendar.

        The method should return the exact timestamp of the end of the anchor_year's
        0 interval, e.g., for the AdventCalendar:
        pd.Timestamp(year, self.month, self.day)

        Args:
            year (int): anchor year for which the anchor timestamp should be generated

        Returns:
            pd.Timestamp: Timestamp at the end of the anchor_years interval 0.
        """
        return pd.Timestamp()

    def _map_year(self, year: int) -> pd.Series:
        """Internal routine to return a concrete IntervalIndex for the given year.

        Since the WeeklyCalendar represents a periodic event, it is first
        instantiated without a specific year. This method adds a specific year
        to the calendar and returns an intervalindex, applying the
        AdvenctCalendar to this specific year.

        Args:
            year: The year for which the WeeklyCalendar will be realized

        Returns:
            Pandas Series filled with Intervals of the calendar's frequency, counting
            backwards from the calendar's anchor_date.
        """
        year_intervals = pd.interval_range(
            end=self._map_year_anchor(year),
            periods=self._get_nintervals(),
            freq=self.freq,
        )

        year_intervals = pd.Series(year_intervals[::-1], name=str(year))
        year_intervals.index.name = "i_interval"
        return year_intervals

    def _get_nintervals(self) -> int:
        """Calculates the number of intervals that should be generated by _map year.

        Returns:
            int: Number of intervals for one anchor year.
        """
        periods_per_year = pd.Timedelta("365days") / pd.to_timedelta(self.freq)
        return (
            (self.max_lag + self.n_targets) if self.max_lag else int(periods_per_year)
        )

    def _get_skip_nyears(self) -> int:
        """Determine how many years need to be skipped to avoid overlapping data.

        Required to prevent information leakage between anchor years.

        Returns:
            int: Number of years that need to be skipped.
        """
        nintervals = self._get_nintervals()
        periods_per_year = pd.Timedelta("365days") / pd.to_timedelta(self.freq)

        return (
            (np.ceil(nintervals / periods_per_year).astype(int) - 1)
            if self.max_lag
            else 0
        )

    def map_years(self, start: int = 1979, end: int = 2020) -> None:
        """Adds a start and end year mapping to the calendar.

        If the start and end years are the same, the intervals for only that single
        year are returned by calendar.get_intervals().

        Args:
            start: The first year for which the calendar will be realized
            end: The last year for which the calendar will be realized

        Returns:
            The calendar mapped to the input start and end year.
        """
        self._first_year = start
        self._last_year = end
        # Overwrite existing map_to_data settings
        self._first_timestamp = None
        self._last_timestamp = None

        return self

    def map_to_data(
        self,
        input_data: Union[pd.Series, pd.DataFrame, xr.Dataset, xr.DataArray],
    ) -> None:
        """Map the calendar to input data period.

        Stores the first and last intervals of the input data to the calendar, so that
        the intervals can cover the data to the greatest extent.

        Args:
            input_data: Input data for datetime mapping. Its index must be either
                pandas.DatetimeIndex, or an xarray `time` coordinate with datetime
                data.

        Returns:
            The calendar mapped to the input data period.
        """
        utils.check_input_data(input_data)

        # check the datetime order of input data
        if isinstance(input_data, PandasData):
            self._first_timestamp = input_data.index.min()
            self._last_timestamp = input_data.index.max()
        else:
            self._first_timestamp = pd.Timestamp(input_data.time.min().values)
            self._last_timestamp = pd.Timestamp(input_data.time.max().values)

        # Set the years to None
        self._first_year = None
        self._last_year = None
        return self

    def _year_range_from_timestamps(self):
        map_first_year = self._first_timestamp.year
        map_last_year = self._last_timestamp.year

        # ensure that the input data could always cover the advent calendar
        # last date check
        if self._map_year(map_last_year).iloc[0].right > self._last_timestamp:
            map_last_year -= 1
        # first date check
        if self._map_year(map_first_year).iloc[-1].left < self._first_timestamp:
            map_first_year += 1

        # map year(s) and generate year realized advent calendar
        if map_last_year >= map_first_year:
            self._first_year = map_first_year
            self._last_year = map_last_year
        else:
            raise ValueError(
                "The input data could not cover the target advent calendar."
            )

        return self

    def _label_targets(self, intervals: pd.DataFrame) -> pd.DataFrame:
        """Adds target labels to the header row of the intervals.

        Args:
            intervals (pd.Dataframe): Dataframe with intervals.

        Returns:
            pd.Dataframe: Dataframe with target periods labelled.
        """
        return intervals.rename(
            columns={i: f"(target) {i}" for i in range(self.n_targets)}
        )

    def get_intervals(self):
        """Method to retrieve updated intervals from the Calendar object."""
        if self._first_year is None:
            if self._first_timestamp is None:
                raise ValueError(
                    "Cannot retrieve intervals without map_years or "
                    "map_to_data having configured the calendar."
                )
            self._year_range_from_timestamps()

        year_range = range(
            self._last_year, self._first_year - 1, -(self._get_skip_nyears() + 1)
        )

        intervals = pd.concat([self._map_year(year) for year in year_range], axis=1).T

        intervals.index.name = "anchor_year"
        return intervals

    @abstractmethod
    def show(self):
        """Display the intervals nicely."""
        return self._label_targets(self.get_intervals())

    def __repr__(self):
        """String representation of the Calendar."""
        props = ", ".join(
            [f"{k}={v}" for k, v in self.__dict__.items() if not k.startswith("_")]
        )
        calendar_name = self.__class__.__name__
        return f"{calendar_name}({props})"

    @property
    def flat(self) -> pd.DataFrame:
        """Returns the flattened intervals."""
        return self.get_intervals().stack()
