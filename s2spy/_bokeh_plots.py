import numpy as np
import pandas as pd
from bokeh import plotting


def make_color_array(n_targets: int, n_intervals: int) -> np.ndarray:
    """Util that generates the colormap for the intervals.

    Args:
        n_targets: number of target intervals
        n_intervals: total number of intervals

    Returns:
        1-D array containing hex colors.
    """
    colors = np.array(["#ffffff"] * n_intervals)
    colors[0:n_targets:2] = "#ff7700"
    colors[1:n_targets:2] = "#ffa100"
    colors[n_targets::2] = "#1f9ce9"
    colors[n_targets + 1 :: 2] = "#137fc1"
    return colors


def _get_xdata(
    relative_dates: bool,
    year_intervals: np.ndarray,
    widths: np.ndarray,
    anchor_date: pd.Timestamp,
) -> np.ndarray:
    """Util that generates the x-coordinate of every interval rectangle for the plot.

    Args:
        relative_dates: If False, absolute dates will be used. If True, each anchor year
                        is aligned by the anchor date, so that all anchor years line up
                        vertically.
        year_intervals: The array of intervals for a single anchor year.
        widths: Width of each interval, as generated by _get_widths.
        anchor_date: The anchor date.

    Returns:
        1-D array containing the x-coordinates for every interval rectangle.
    """
    if relative_dates:
        x_data = np.array([(anchor_date - i.right).days for i in year_intervals])
        return x_data + 0.5 * widths

    x_data = np.array([i.right for i in year_intervals])
    return x_data - 0.5 * widths


def _get_widths(
    relative_dates: bool,
    year_intervals: np.ndarray,
) -> np.ndarray:
    """Util that generates the width of every interval rectangle for the plot.

    Args:
        relative_dates: If False, absolute dates will be used. If True, each anchor year
                        is aligned by the anchor date, so that all anchor years line up
                        vertically.
        year_intervals: The array of intervals for a single anchor year.

    Returns:
        1-D array containing the width of every interval rectangle.
    """
    if relative_dates:
        return np.array([(i.right - i.left).days for i in year_intervals])
    return np.array([(i.right - i.left) for i in year_intervals])


def _generate_bokeh_source(
    relative_dates: bool,
    year_intervals: np.ndarray,
    n_targets: int,
) -> plotting.ColumnDataSource:
    """Util to generate the bokeh "source", containing all variables to plot.

    Args:
        relative_dates: If False, absolute dates will be used. If True, each anchor year
                        is aligned by the anchor date, so that all anchor years line up
                        vertically.
        year_intervals: The array of intervals for a single anchor year.

        n_targets: The number of target intervals in the calendar.

    Returns:
        plotting.ColumnDataSource
    """
    anchor_date = year_intervals[0].right

    widths = _get_widths(relative_dates, year_intervals)
    interval_str = np.array(
        [f"{str(i.left)[:10]} -> {str(i.right)[:10]}" for i in year_intervals]
    )

    types = np.array(["Precursor"] * len(year_intervals))
    types[:n_targets] = "Target"

    width_days = widths if relative_dates else np.array([x.days for x in widths])

    return plotting.ColumnDataSource(
        data={
            "x": _get_xdata(relative_dates, year_intervals, widths, anchor_date),
            "y": np.ones(len(year_intervals)) * anchor_date.year,
            "height": np.ones(len(year_intervals)) * 0.8,
            "width": widths,
            "width_days": width_days,
            "color": make_color_array(n_targets, len(year_intervals)),
            "desc": interval_str,
            "type": types,
        }
    )


def _generate_rectangle(
    figure: plotting.figure, source: plotting.ColumnDataSource
) -> plotting.figure:
    """Adds intervals to the figure as rectangles.

    Args:
        figure: Bokeh figure in which the rectangles should be added.
        source: Bokeh source data containing the required parameters.

    Returns:
        plotting.figure
    """
    return figure.rect(
        x="x",
        y="y",
        width="width",
        height="height",
        line_color="#000000",
        fill_color="color",
        fill_alpha=0.7,
        line_width=1.5,
        source=source,
    )


def _bokeh_visualization(
    calendar, n_years: int, relative_dates: bool
) -> plotting.Figure:
    """Visualization routine for generating a calendar visualization with Bokeh.

    Args:
        calendar: Mapped calendar which should be visualized.
        n_years: Number of years which should be displayed (most recent years only).
        relative_dates: If False, absolute dates will be used. If True, each anchor year
                        is aligned by the anchor date, so that all anchor years line up
                        vertically.

    Returns:
        plotting.Figure
    """

    tooltips = [("Interval", "@desc"), ("Size", "@width_days days"), ("Type", "@type")]
    figure = plotting.figure(
        width=500,
        height=300,
        tooltips=tooltips,
        x_axis_type="linear" if relative_dates else "datetime",
    )

    intervals = calendar.get_intervals()[:n_years]

    for year_intervals in intervals.values:
        source = _generate_bokeh_source(
            relative_dates=relative_dates,
            year_intervals=year_intervals,
            n_targets=calendar.n_targets,
        )
        _generate_rectangle(figure, source)

    figure.xaxis.axis_label = "Days before anchor date" if relative_dates else "Date"
    figure.yaxis.axis_label = "Anchor year"

    if relative_dates:
        figure.x_range.start = (
            np.max(source.data["x"])
            +
            # pylint: disable=unsubscriptable-object
            np.max(source.data["width"])
            + 10
        )
        figure.x_range.end = -10

    figure.yaxis.ticker = [int(x) for x in intervals.index.to_list()]

    return figure


def bokeh_visualization(calendar, n_years, relative_dates):
    figure = _bokeh_visualization(calendar, n_years, relative_dates)
    plotting.show(figure)
